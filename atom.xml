<?xml version="1.0" encoding="UTF-8"?><feed xmlns:a="http://www.w3.org/2005/Atom"><id>urn:oubiwann-github-io/blog:feed</id><updated>2018-07-19 00:28:43</updated><title type="text">o|b</title><link rel="self" href="http://oubiwann.github.io/blog/blog/atom.xml"/><entry><title>Followup: New Versions of Clojang Agent and API Published on Clojars</title><updated>2018-07-19 00:28:43</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2018-07/19-002843/followup-new-versions-of-clojang-agent-and-api-published-on-clojars.html"/><id>urn:oubiwann-github-io/blog:feed:post:Followup: New Versions of Clojang Agent and API Published on Clojars</id><content type="html">&lt;p&gt;As with the &lt;a href='/archives/2018-07/17-191932/new-versions-of-jinterface-and-jiface-published-on-clojars.html'&gt;post from the other day&lt;/a&gt;, tonight (this morning) has seen the two other core Clojang libraries get updates. The agent lib in particular is a cause for celebration, since there's been an out-standing issue with failing builds for the past year (a dep with AOT'ed classes was the primary suspect; unlike the vanilla class-not-found-due-to AOT'ed JAR file collisions, this one was particulaly nasty/unusual ... hadn't seen anything like it before). That issue is now closed and builds are successful again.&lt;/p&gt;&lt;p&gt;The agent is the means by which a JVM process can emulate the behaviour of an Erlang/OTP process (with regard to its messaging inbox, node name assignment, and other defaults set up automatically, keeping thigs simple for the developer).&lt;/p&gt;&lt;p&gt;The long-awaited fix allowed me to pump out the following agent releases:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/agent/versions/0.4.0'&gt;agent 0.4.0&lt;/a&gt; for Erlang 19.2 and 19.3 (uses JInterface 1.7.1)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/agent/versions/0.5.0'&gt;agent 0.5.0&lt;/a&gt; for Erlang 20.3 (uses JInterface 1.8.1)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/agent/versions/0.6.0'&gt;agent 0.6.0&lt;/a&gt; for Erlang 21.0 (uses JInterface 1.9)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;And then the clojang API releases that depended upon the different agent versions:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/clojang/versions/0.4.0'&gt;clojang 0.4.0&lt;/a&gt; for Erlang 19.2 and 19.3 (uses JInterface 1.7.1)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/clojang/versions/0.5.0'&gt;clojang 0.5.0&lt;/a&gt; for Erlang 20.3 (uses JInterface 1.8.1)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/clojang/versions/0.6.0'&gt;clojang 0.6.0&lt;/a&gt; for Erlang 21.0 (uses JInterface 1.9)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Still coming up ...&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Port more Erlang/Java examples to LFE/Clojure&lt;/li&gt;&lt;li&gt;Demonstrate use with the Clojure Component library&lt;/li&gt;&lt;li&gt;Demonstrate managing throw-away JVM instances from Erlang/LFE, managed via JMX&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>New Versions of JInterface and jiface Published on Clojars</title><updated>2018-07-17 19:19:32</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2018-07/17-191932/new-versions-of-jinterface-and-jiface-published-on-clojars.html"/><id>urn:oubiwann-github-io/blog:feed:post:New Versions of JInterface and jiface Published on Clojars</id><content type="html">&lt;p&gt;Since the last updates to the Clojure libraries, Erlang has had several major releases. Today, I was able to catch up and publish the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/erlang-jinterface/versions/1.8.1'&gt;JInterface 1.8.1&lt;/a&gt; for Erlang 20.3 (ERTS 9.3)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/erlang-jinterface/versions/1.9'&gt;JInterface 1.9&lt;/a&gt; for Erlang 21.0 (ERTS 10)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These are now available on Clojars.&lt;/p&gt;&lt;p&gt;Also now on Clojars are the following low-level Clojure API releases:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/jiface/versions/0.4.0'&gt;jiface 0.4.0&lt;/a&gt; for Erlang 19.2 and 19.3 (uses JInterface 1.7.1)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/jiface/versions/0.5.0'&gt;jiface 0.5.0&lt;/a&gt; for Erlang 20.3 (uses JInterface 1.8.1)&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojars.org/clojang/jiface/versions/0.6.0-SNAPSHOT'&gt;jiface 0.6.0-SNAPSHOT&lt;/a&gt; for Erlang 21.0 (uses JInterface 1.9)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Coming up:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Similar updates for the JVM agent and the hi-level API (clojang-proper)&lt;/li&gt;&lt;li&gt;Port more Erlang/Java examples to LFE/Clojure&lt;/li&gt;&lt;li&gt;Demonstrate use with the Clojure Component library&lt;/li&gt;&lt;li&gt;Demonstrate managing throw-away JVM instances from Erlang/LFE, managed via JMX&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Project Split: Clojang + Clozhang</title><updated>2017-10-15 18:42:09</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-10/15-184209/project-split-clojang-clozhang.html"/><id>urn:oubiwann-github-io/blog:feed:post:Project Split: Clojang + Clozhang</id><content type="html">&lt;p&gt;After all the thinking last night, I woke up ready to tackle the new work on &amp;pi;-Calculus in Clojure :-) First off, there's a new logo!&lt;/p&gt;&lt;p&gt;&lt;a href="https://raw.githubusercontent.com/clozhang/resources/master/images/logo-6-2100x.png"&gt; &lt;img src="https://raw.githubusercontent.com/clozhang/resources/master/images/logo-6-250x.png"&gt; &lt;/a&gt;&lt;/p&gt;&lt;p&gt;Most obviously, there's the new blog you're reading :-)&lt;/p&gt;&lt;p&gt;Addtionally, other new resources include:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a &lt;a href='https://github.com/clozhang'&gt;Github org&lt;/a&gt;&lt;/li&gt;&lt;li&gt;a &lt;a href='http://clozhang.slack.com/'&gt;Slack channel&lt;/a&gt;&lt;/li&gt;&lt;li&gt;the new &lt;a href='https://groups.google.com/forum/#!forum/clozhang'&gt;mail list&lt;/a&gt;&lt;/li&gt;&lt;li&gt;a &lt;a href='http://twitter.com/clozhang'&gt;Twitter account&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The changes to the old Clojang Github org include the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the resources repo has been moved into the Clozhang org (I didn't want  to fork it, since it has binary image files ... no sense in making  Github's life harder)&lt;/li&gt;&lt;li&gt;the zhang and zhang-agent repos have been moved into the Clozhang org&lt;/li&gt;&lt;li&gt;the old blog has been forked&lt;/li&gt;&lt;li&gt;the Clojang Codox theme has been forked&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;At some point, I'll update the Clojang blog with a note about these changes as well, and point readers here (since this is almost certainly where 99% of all future work will be occurring).&lt;/p&gt;</content></entry><entry><title>Some Ideas for a Clojure &amp;pi;-Calculus Lab</title><updated>2017-10-14 22:32:27</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-10/14-223227/some-ideas-for-a-clojure-pi-calculus-lab.html"/><id>urn:oubiwann-github-io/blog:feed:post:Some Ideas for a Clojure &amp;pi;-Calculus Lab</id><content type="html">&lt;p&gt;I spent all night tonight reviewing my collection of &amp;pi;-Calculus papers and thinking about the ways in which one could implement an extremely simple &amp;pi;-Calculus for Clojure. In part, this involved reflecting on Erlang's general architecture (from the perspective of communicating nodes and processes).&lt;/p&gt;&lt;p&gt;I think I've got a plan for tackling this in what is essentially a "&amp;pi;-Calculus lab" &amp;ndash; two JVM instances and a simple distributed messaging/storage solution. This would allow mem to simply focus on the mechanics of communicating processes/functions without getting bogged down in developing a system. That can come later, once various avenues have been explored in the "lab".&lt;/p&gt;&lt;p&gt;I'm pretty stoked to get started on this :-)&lt;/p&gt;</content></entry><entry><title>Renewed Interest in the &amp;pi;-Calculus</title><updated>2017-10-13 23:42:42</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-10/13-234242/renewed-interest-in-the-pi-calculus.html"/><id>urn:oubiwann-github-io/blog:feed:post:Renewed Interest in the &amp;pi;-Calculus</id><content type="html">&lt;p&gt;Today after Guy Steele's keynote at Clojure/conj, and handful of folks went up to the stage to hang out and ask questions. It was quite a moment, really (so much so that I was pretty blissed out for several hours afterwards). I forget the question asked, but at one point Guy responded with an answer where he mentioned the &amp;pi;-Calculus.&lt;/p&gt;&lt;p&gt;In various previous and subsequent conversations, both LFE and Erlang came up where the points being made/joys being shared had to to with the very special strengths the BEAM provides due to its implementation of the &amp;pi;-Calculus (admittedly, without &amp;pi;-Calculus being mentioned per se).&lt;/p&gt;&lt;p&gt;There's a particular Clojure project I have touched on and off for almost two years now whose goal has been to follow up on earlier work that blended Clojure and Erlang &amp;ndash; but to completely drop the dependency upon the Java implementation of the Erlang interface.&lt;/p&gt;&lt;p&gt;Now that I'm thinking about this again, I'm having new ideas on how to tackly the problem, purely with Clojure.&lt;/p&gt;&lt;p&gt;More soon ...&lt;/p&gt;</content></entry><entry><title>NASA/EOSDIS Earthdata</title><updated>2017-08-09 17:23:08</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-08/09-172308/nasa-eosdis-earthdata.html"/><id>urn:oubiwann-github-io/blog:feed:post:NASA/EOSDIS Earthdata</id><content type="html">&lt;p&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://3.bp.blogspot.com/-t6djJucJIQM/WYt6wLms3UI/AAAAAAAAB24/Ur3nVSU0W 1IKzzD6tzNua-rQYc&lt;i&gt;ZsEo0ACLcBGAs/s1600/1237px-NASA&lt;/i&gt;logo.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"&gt;&lt;img border="0" data-original-height="1024" data-original-width="1237" height="264" src="https://3.bp.blogspot.com/-t6djJucJIQM/WYt6wLms3UI/AAAAAAAAB24/Ur3nVSU0W1 IKzzD6tzNua-rQYc&lt;i&gt;ZsEo0ACLcBGAs/s320/1237px-NASA&lt;/i&gt;logo.png" width="320" /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h2&gt;Update&lt;/h2&gt;It's been a few years since I posted on this blog &amp;ndash; most of the technical content I've been contributing to in the past couple years has been in the following:&lt;br /&gt;&lt;blockquote&gt;&lt;ul style="padding-left: 1em;"&gt;&lt;li&gt;&lt;a href="http://blog.lfe.io/"&gt;The LFE Blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://clojang.lfe.io/"&gt;The Clojang Blog&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;But since the publication of the &lt;a href="https://www.amazon.com/gp/product/1783987545/ref=as&lt;i&gt;li&lt;/i&gt;tl?ie=UTF8&amp;amp;ca mp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1783987545&amp;amp;linkCode=as2&amp;amp;tag =forgottenroad-20&amp;amp;linkId=9bf1fc9b1edf875130800eead4c925b2" target="_blank"&lt;blockquote&gt;&lt;p&gt;Mastering matplotlib&lt;/a&gt; book, I've gotten more and more into satellite data. The book, it goes without saying, focused on Python for the analysis and interpretation of satellite data (in one of the many topics covered). After that I spent some time working with satellite and GIS data in general using Erlang and LFE. Ultimately though, I found that more and more projects were using the JVM for this sort of work, and in particular, I noted that Clojure had begun to show up in a surprising number of Github projects.&lt;br /&gt;&lt;br /&gt;&lt;h2 class="separator" style="clear: both; text-align: left;"&gt;&lt;a href="https://2.bp.blogspot.com/-Yv097EqrTEo/WYuCpxJ1XhI/AAAAAAAAB3U/Mmgae_Gb5 dcNaFeDgzZcUtPBybBHDuw2ACEwYBhgL/s1600/eosdis-logo.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"&gt;&lt;img border="0" data-original-height="507" data-original-width="1600" height="101" src="https://2.bp.blogspot.com/-Yv097EqrTEo/WYuCpxJ1XhI/AAAAAAAAB3U/Mmgae_Gb5d cNaFeDgzZcUtPBybBHDuw2ACEwYBhgL/s320/eosdis-logo.png" width="320" /&gt;&lt;/a&gt;EOSDIS&lt;/h2&gt;Enter NASA's &lt;a href="https://earthdata.nasa.gov/about"&gt;Earth Observing System Data and Information System&lt;/a&gt; (see also &lt;a href="http://earthdata.nasa.gov/"&gt;earthdata.nasa.gov&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/EOSDIS"&gt;EOSDIS on Wikipedia&lt;/a&gt;), a key part of the agency's Earth Science Data Systems Program. It's essentially a concerted effort to bring together the mind-blowing amounts of earth-related data being collected throughout, around, and above the world so that scientists may easily access and correlate earth science data for their research.&lt;br /&gt;&lt;br /&gt;Related NASA projects include the following:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://eospso.nasa.gov/"&gt;EOS&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://earthdata.nasa.gov/about/esdis-project"&gt;ESDIS&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a hre f="https://espd.gsfc.nasa.gov/esmo.html"&gt;ESMO&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;The acronym menagerie can be bewildering, but digging into the various NASA projects is ultimately quite rewarding (greater insights, previously unknown resources, amazing research, etc.).&lt;br /&gt;&lt;br /&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-6wXWCH0a44U/WYuIz7DNAgI/AAAAAAAAB4A/ixveCzQky mwa31AqEK7QULXgNMuQFVZMgCLcBGAs/s1600/Clojure-logo-tiny.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"&gt;&lt;img border="0" data-original-height="128" data-original-width="128" src="https://1.bp.blogspot.com/-6wXWCH0a44U/WYuIz7DNAgI/AAAAAAAAB4A/ixveCzQkym wa31AqEK7QULXgNMuQFVZMgCLcBGAs/s1600/Clojure-logo-tiny.png" /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h2&gt;Cl ojure&lt;/h2&gt;Back to the Clojure reference I made above:&amp;nbsp; I've been contributing to the &lt;a href="https://github.com/nasa/Common-Metadata-Repository"&gt;nasa/Common-Metadata -Repository&lt;/a&gt; open source project (hosted on Github) for a few months now, and it's been amazing to see how all this data from so many different sources gets added, indexed, updated, and generally made so much more available to any who want to work with it. The private sector always seems to be so far ahead of large projects in terms of tech and continuously improving updates to existing software, so its been pretty cool to see a large open source project in the NASA Github org make so many changes that find ways to keep helping their users do better research. More so that users are regularly delivered new features in a large, complex collection of libraries and services thanks in part to the benefits that come from using a functional programming language.&lt;br /&gt;&lt;br /&gt;It may seem like nothing to you, but the fact that there are now &lt;a href="https://cmr.earthdata.nasa.gov/search/site/collections/directory/eosdis" target="_blank"&gt;directory pages&lt;/a&gt; for various data providers (e.g., &lt;a href="https://cmr.earthdata.nasa.gov/search/site/collections/directory/GES_DIS C/gov.nasa.eosdis" target="&lt;i&gt;blank"&gt;GES&lt;/i&gt;DISC&lt;/a&gt;, i.e., &lt;a href="https://earthdata.nasa.gov/about/daacs/daac-ges-disc" target="_blank"&gt;Go ddard Earth Sciences Data and Information Services Center&lt;/a&gt;) makes a big difference for users of this data. The data provider pages now also offer easy access to collection links such as &lt;a href="https://cmr.earthdata.nasa.gov/search/concepts/C1273348625-GES_DISC.html " target="_blank"&gt;UARS Solar Ultraviolet Spectral Irradiance Monitor&lt;/a&gt;. Admittedly, the directory pages still take a while to load, but there are improvements on the way for page load times and other related tasks. If you're reading this a month after this post was written, there's a good chance it's already been fixed by now.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Summary &lt;/h2&gt;In summary, it's been a fun personal journey from looking at Landsat data for writing a book to working with open source projects that really help scientists to do their jobs better :-) And while I have enjoyed using the other programming languages to explore this problem space, Clojure in particular has been a delightfully powerful tool for delivering new features to the science community.  &lt;/p&gt;&lt;/blockquote&gt;&lt;/p&gt;</content></entry><entry><title>New Clojang Blog</title><updated>2017-03-16 00:47:34</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-03/16-004734/new-clojang-blog.html"/><id>urn:oubiwann-github-io/blog:feed:post:New Clojang Blog</id><content type="html">&lt;p&gt;After a few weeks of hacking and furtive hosting of alpha code and alpha-er content, I think the blog's ready to have more eyeballs on it. It's mostly a vehicle for sharing Clojang project code snippets, clarifying documentation (and then using that to go update the docs!), provide updates on version releases, and maybe even share the occasional experiment. Though it should be fairly low-volume and low-impact, it seemed like a nice way increase the contact area for curious developers who have to (or want to!) straddle the two very different worlds of the JVM (Clojure in particular) and BEAM.&lt;/p&gt;&lt;p&gt;I might not ever have created a dedicated blog for Clojang, but there's been a growing interest among fellow LFErs and BEAMers in general, as well as from curious Clojurians. After the 5th or 6th recent conversation, it was time to do something. One comment in particular, that I should create a &lt;code&gt;STATUS.md&lt;/code&gt; file in the one or more repos really motivated me to do something about a Clojang blog.&lt;/p&gt;&lt;p&gt;For the archivally inclined, the following notes may be of interest. I've been able to reconstruct the older posts from old notes, repositories, and emails, but the furthest back I could find was work I was doing on &lt;a href='https://github.com/Elzor'&gt;Maxim Molchanov&lt;/a&gt;'s &lt;a href='https://github.com/Elzor/erlang-clojure-node'&gt;erlang-clojure-node&lt;/a&gt; repository. There was work done earlier, but I can't find it anywhere, since I don't think any of that got committed. However, it wasn't any time before the end of 2013, so I didn't lose much :-)&lt;/p&gt;&lt;p&gt;There was also some forking I did of &lt;a href='https://github.com/awetzel'&gt;Arnaud Wetzel&lt;/a&gt;'s &lt;a href='https://github.com/awetzel/clojure-erlastic'&gt;clojure-erlastic&lt;/a&gt; repository, but which has since been deleted from Github since that was abandoned and a completely different tack was chosen. I do have an older repo of that on disk somewhere, so if anyone's interested, I can push it up to a Clojang attic ...&lt;/p&gt;&lt;p&gt;Anyway, all this is to say that most of the important stuff has been preserved and the interesting bits are now either in the various &lt;a href='http://github.com/clojang'&gt;Clojang&lt;/a&gt; repos or they've been published on the blog.&lt;/p&gt;&lt;p&gt;One last thing: comments are on the way ... but they will be a bit unusual: each blog post that has comments enabled will link to a dedicated ticket on Github &lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;/p&gt;</content></entry><entry><title>Clojang Mail List &amp; Slack Channel</title><updated>2017-03-12 21:25:49</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-03/12-212549/clojang-mail-list-slack-channel.html"/><id>urn:oubiwann-github-io/blog:feed:post:Clojang Mail List &amp; Slack Channel</id><content type="html">&lt;h2&gt;Mail List&lt;/h2&gt;&lt;p&gt;A mail list for Clojang has been created and is availble for user subscriptions here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://groups.google.com/forum/#!forum/clojang'&gt;https://groups.google.com/forum/#!forum/clojang&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Once subscribed, you may send emails to the list via clojang@googlegroups.com.&lt;/p&gt;&lt;h2&gt;Slack&lt;/h2&gt;&lt;p&gt;Additionally, a Slack channel has been set up at &lt;a href='http://clojang.slack.com'&gt;clojang.slack.com&lt;/a&gt;. However, you need an invite in order to join the rooms. If you would like to participate in Clojang development or usage discussions, send a direct message to &lt;a href='http://twitter.com/clojang'&gt;@Clojang&lt;/a&gt; (requires mutual follow) or open a &lt;a href='https://github.com/clojang/slack/issues/new'&gt;Slack invitation request ticket&lt;/a&gt;.&lt;/p&gt;</content></entry><entry><title>Clojang is on Twitter</title><updated>2017-03-04 20:19:18</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-03/04-201918/clojang-is-on-twitter.html"/><id>urn:oubiwann-github-io/blog:feed:post:Clojang is on Twitter</id><content type="html">&lt;p&gt;The Clojang project now has a &lt;a href='https://twitter.com/clojang'&gt;Twitter account&lt;/a&gt; :-)&lt;/p&gt;</content></entry><entry><title>Progress Towards the Next Releases</title><updated>2017-03-01 23:52:10</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-03/01-235210/progress-towards-the-next-releases.html"/><id>urn:oubiwann-github-io/blog:feed:post:Progress Towards the Next Releases</id><content type="html">&lt;p&gt;An enormous amount of work has been going on in Clojang-land lately &amp;ndash; enough so that a new release is imminent. The work in jiface and clojang is being driven almost entirely by the long-awaited rewrite of &lt;a href='lfecljapp'&gt;lfecljapp&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The tickets have all been organized into a release, epics, features, tasks, etc., and are linked from this one ticket here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/lfecljapp/issues/20'&gt;isuse #20 - Release 0.4.0&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Clojang, JInterface, &amp; core.async</title><updated>2017-02-24 01:42:24</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-02/24-014224/clojang-jinterface-core-async.html"/><id>urn:oubiwann-github-io/blog:feed:post:Clojang, JInterface, &amp; core.async</id><content type="html">&lt;p&gt;The discussion on Slack the other day kicked off with a question about how messages are consumed in Clojang (and thus jiface and JInterface), and whether, in Clojure code, one could use &lt;code&gt;core.async&lt;/code&gt; to do this.&lt;/p&gt;&lt;p&gt;We'll take a very quick deep (while at the same time superficial) dive into this, but then answer some broader questions to provide a better context for JInterface and the projects built upon it.&lt;/p&gt;&lt;h2&gt;Receiving Messages&lt;/h2&gt;&lt;p&gt;If you are using the &lt;code&gt;clojang&lt;/code&gt; library, receiving messages is as simple as the following (assuming you've followed the best practice of adding the Clojang &lt;code&gt;agent&lt;/code&gt; dependency in your &lt;code&gt;project.clj&lt;/code&gt; file and set the &lt;code&gt;:java-agents&lt;/code&gt; option):&lt;/p&gt;&lt;pre&gt;&lt;code class="cl"&gt;&amp;#40;require '&amp;#91;clojang.core :refer &amp;#91;receive&amp;#93;&amp;#93;

&amp;#40;receive&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At which point, your code blocks until a message is received. When a message comes in, &lt;code&gt;clojang&lt;/code&gt; will automatically convert the Java-OTP hybrid types to Clojure types; when you reply, the conversion will take place in the other direction.&lt;/p&gt;&lt;p&gt;A fuller examples is viewable here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/lfecljapp/blob/master/src/clj/cljnode/server.clj'&gt;https://github.com/clojang/lfecljapp/blob/master/src/clj/cljnode/server.clj&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Under the hood (in the &lt;code&gt;clojang&lt;/code&gt; library), a default OTP node and associated mbox are being used (using the Clojure-idiomatic library &lt;code&gt;jiface&lt;/code&gt;). Under &lt;em&gt;that&lt;/em&gt; hood, Erlang's JInterface Java library is using threads, sockets, and custom queues to handle in-coming and out-going messages.&lt;/p&gt;&lt;p&gt;In other words, not a lot of room for &lt;code&gt;core.async&lt;/code&gt;, unfortunately.&lt;/p&gt;&lt;p&gt;However, there's a &lt;em&gt;little&lt;/em&gt; bit of room :-)&lt;/p&gt;&lt;h2&gt;Command &amp; Convenience Channels&lt;/h2&gt;&lt;p&gt;One way I use &lt;code&gt;core.async&lt;/code&gt; in Clojang applications is to facilitate communications between Clojure functions (i.e., a Clojang server and client, both written in Clojure).&lt;/p&gt;&lt;p&gt;Here's a Clojure server that takes a &lt;code&gt;core.async&lt;/code&gt; channel as an argument:&lt;/p&gt;&lt;pre&gt;&lt;code class="clj"&gt;&amp;#40;defn run
  &amp;#91;cmd-chan&amp;#93;
  &amp;#40;log/info &amp;quot;Starting Clojure node with nodename =&amp;quot;
            &amp;#40;System/getProperty &amp;quot;node.sname&amp;quot;&amp;#41;&amp;#41;
  &amp;#40;let &amp;#91;init-state 0&amp;#93;
    &amp;#40;loop &amp;#91;png-count init-state&amp;#93;
      &amp;#40;match &amp;#40;receive&amp;#41;
        &amp;#91;:register caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/infof &amp;quot;Got :register request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;mbox/link &amp;#40;self&amp;#41; caller&amp;#41;
            &amp;#40;! caller :linked&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;
        &amp;#91;:ping caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/infof &amp;quot;Got :ping request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;! caller :pong&amp;#41;
            &amp;#40;recur &amp;#40;inc png-count&amp;#41;&amp;#41;&amp;#41;
        &amp;#91;:get-ping-count caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/infof &amp;quot;Got :get-ping-count request from %s ...&amp;quot;  caller&amp;#41;
            &amp;#40;! caller png-count&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;
        &amp;#91;:stop caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/warnf &amp;quot;Got :stop request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;! caller :stopping&amp;#41;
            :stopped&amp;#41;
        &amp;#91;:shutdown caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/warnf &amp;quot;Got :shutdown request from %s ...&amp;quot; caller&amp;#41;
            &amp;#40;! caller :shutting-down&amp;#41;
            &amp;#40;async/&amp;gt;! cmd-chan :shutdown&amp;#41;&amp;#41;
        &amp;#91;&amp;#95; caller&amp;#93;
          &amp;#40;do
            &amp;#40;log/error &amp;quot;Bad message received: unknown command&amp;quot;&amp;#41;
            &amp;#40;! caller &amp;#91;:error :unknown-command&amp;#93;&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;
        &amp;#91;&amp;#95;&amp;#93;
          &amp;#40;do
            &amp;#40;log/error &amp;quot;Bad message received: improperly formatted&amp;quot;&amp;#41;
            &amp;#40;recur png-count&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this particular case, it doesn't do too much: it simply sends a message back to the calling code when the server has been asked to shutdown. (Note that the &lt;code&gt;:shutdown&lt;/code&gt; clause is sending two types of messages: first an OTP message reply is sent back to the calling OTP node &amp;ndash; which could be either another OTP Clojure node or a BEAM node &amp;ndash; and then a &lt;code&gt;core.async&lt;/code&gt; message is pushed onto the channel that was passed to the server function. In the case where this code was copied from, that channel was started by the function that called &lt;code&gt;&amp;#40;run&amp;#41;&lt;/code&gt;.)&lt;/p&gt;&lt;p&gt;That's a really simple (and not strictly necessary) example of a command channel use case for &lt;code&gt;core.async&lt;/code&gt; in a Clojang app. Here's another case:&lt;/p&gt;&lt;pre&gt;&lt;code class="clj"&gt;&amp;#40;defn otp-bridge
  &amp;quot;This function creates the following in order to facilitate core.async
  communications with the Clojure OTP server:
&lt;ol&gt;&lt;li&gt;A dedicated mbox for the OTP bridge &amp;#40;what receives messages from the       OTP server&amp;#41;
    2. The pid for the dedicated mbox
    3. A core.async channel for sending messages to the OTP server.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;bridge-mbox &amp;#40;mbox/add :otpbrige&amp;#41;
        bridge-pid &amp;#40;mbox/get-pid bridge-mbox&amp;#41;
        bridge-chan &amp;#40;async/chan&amp;#41;&amp;#93;
    &amp;#40;async/go-loop &amp;#91;&amp;#93;
      &amp;#40;when-let &amp;#91;value &amp;#40;async/&amp;lt;! bridge-chan&amp;#41;&amp;#93;
        &amp;#40;! &amp;#91;value bridge-pid&amp;#93;&amp;#41;&amp;#41;
      &amp;#40;recur&amp;#41;&amp;#41;
    {:mbox bridge-mbox
     :pid bridge-pid
     :channel bridge-chan}&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;As the docstring above says, this function uses &lt;code&gt;core.async&lt;/code&gt; to provide a wrapper for OTP communications with a Clojang server. Interesting and kind of fun, but not really tapping into the power of &lt;code&gt;core.async&lt;/code&gt;.&lt;/p&gt;&lt;h2&gt;Zhang&lt;/h2&gt;&lt;p&gt;There is an experimental project for exploring ways in which Clojure/OTP applications could maximize &lt;code&gt;core.async&lt;/code&gt; while communicating with nodes, services, and full distributed systems in the BEAM world:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='/archives/2016-02/13-121526/zhang.html'&gt;Zhang&lt;/a&gt;  (blog post/project announcement)&lt;/li&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/zhang'&gt;zhang on github&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Those two links provide some good introductory material, so I won't duplicate that here. Note, however, than while the &lt;code&gt;jiface&lt;/code&gt; and &lt;code&gt;clojang&lt;/code&gt; libs are stabilizing, little effort is being applied to &lt;code&gt;zhang&lt;/code&gt;. As such, there's not much to the project currently.&lt;/p&gt;</content></entry><entry><title>clojang &amp; agent v0.3.0 Released</title><updated>2017-01-17 19:48:58</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2017-01/17-194858/clojang-agent-v0-3-0-released.html"/><id>urn:oubiwann-github-io/blog:feed:post:clojang &amp; agent v0.3.0 Released</id><content type="html">&lt;p&gt;The new releases are available here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/clojang/releases/tag/0.3.0'&gt;clojang&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/agent/releases/tag/0.3.0'&gt;agent&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Enjoy!&lt;/p&gt;</content></entry><entry><title>jiface &amp; clojang-agent v0.1.0 Released</title><updated>2016-04-30 21:43:38</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2016-04/30-214338/jiface-clojang-agent-v0-1-0-released.html"/><id>urn:oubiwann-github-io/blog:feed:post:jiface &amp; clojang-agent v0.1.0 Released</id><content type="html">&lt;p&gt;The new releases are available here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/jiface/releases/tag/0.1.0'&gt;jiface&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/clojang/agent/releases/tag/0.1.0'&gt;agent&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Enjoy!&lt;/p&gt;</content></entry><entry><title>LFE and rebar3</title><updated>2016-03-25 08:58:08</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2016-03/25-085808/lfe-and-rebar3.html"/><id>urn:oubiwann-github-io/blog:feed:post:LFE and rebar3</id><content type="html">&lt;p&gt;&lt;a href="/assets/images/posts/lfe-rebar3-logo.png"&gt;&lt;img class="left thumb" src="{{ site.base_url }}/assets/images/posts/lfe-rebar3-logo.png" /&gt;&lt;/a&gt; This post provides a quick introduction to using ``rebar3`` in LFE projects or in Erlang+LFE projects. After this quick read, you'll be able to jump right in to LFE development in projects managed with ``rebar3`` :-) &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;&lt;p&gt;With the support of namespaces landing in ``rebar3`` last year, the LFE community started making slow but steady progress toward adopting ``rebar3`` as its preferred tool for building projects, running tests, creating releases, examining dependency trees, generating docs, and creating generally useful, project-oriented command-line tools.&lt;/p&gt;&lt;p&gt;As a community, we've still got a ways to go before we completely reproduce all the functionality that has been provided by ``lfetool``, but every new LFE plugin brings us closer to that goal.&lt;/p&gt;&lt;p&gt;Note that this post assumes that you already have Erlang installed on your system.&lt;/p&gt;&lt;h2&gt;Installing ``rebar3``&lt;/h2&gt;&lt;p&gt;There are several ways to get ``rebar3`` (including building it yourself), but most of us use the readily available option provided on the project's &lt;a href='https://github.com/erlang/rebar3'&gt;README&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ wget https://s3.amazonaws.com/rebar3/rebar3 &amp;amp;&amp;amp; chmod +x rebar3
$ sudo mv rebar3 /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the nightly build. I have been very happy with the nightlies and have used them consistently in both development and production without any issues. If you'd like to read more about installing ``rebar3``, be sure to check out the &lt;a href='http://www.rebar3.org/docs/getting-started'&gt;getting started page&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;Compiling LFE Files&lt;/h2&gt;&lt;p&gt;With ``rebar3`` installed, you're ready to rock and roll: bringing LFE into an Erlang project is as simple as updating your ``rebar.config`` file. (Note that if you are moving from ``rebar`` to ``rebar3``, it is indeed a &lt;em&gt;move&lt;/em&gt;: for the most part, ``rebar3`` configuration options are not backwards compatible with ``rebar``).&lt;/p&gt;&lt;p&gt;If you've got an Erlang project and you want to support adding LFE files to it, here's all you need to do to the project's ``rebar.config``:&lt;/p&gt;&lt;pre&gt;&lt;code class="erlang"&gt;{plugins, &amp;#91;
   {'lfe-compile',
     {git, &amp;quot;https://github.com/lfe-rebar3/compile.git&amp;quot;, {tag, &amp;quot;0.3.0&amp;quot;}}}
  &amp;#93;}.

{provider&amp;#95;hooks, &amp;#91;{pre, &amp;#91;{compile, {lfe, compile}}&amp;#93;}&amp;#93;}.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, add ``.lfe`` source files to your heart's content. When done, simply compile:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 compile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will pull down all the dependencies that the LFE-rebar3 plugin has (including LFE itself), compile all your ``.erl`` files that ``rebar3`` normally does, and then compile any ``.lfe`` files you have added.&lt;/p&gt;&lt;p&gt;Note that if you only want to (re-)compile ``.lfe`` files, you may explicitly call the plugin's compile command:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 lfe compile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If your project is LFE-only (no ``.erl`` files), the set up is exactly the same.&lt;/p&gt;&lt;h2&gt;Bringing in LFE Libraries&lt;/h2&gt;&lt;p&gt;If you'd like to add some of the [community LFE libraries](https://github.com/lfex) to your project, or pull in libraries from somewhere else, simply add them to the ``deps`` section in the ``rebar.config``. Here's how you add the LFE library which allows you to use some Clojure idioms in your LFE code (e.g., the ``-&gt;`` and ``-&gt;&gt;`` thrushing macros):&lt;/p&gt;&lt;pre&gt;&lt;code class="erlang"&gt;{deps, &amp;#91;
   {clj, &amp;quot;.&amp;#42;&amp;quot;, {git, &amp;quot;git://github.com/lfex/clj.git&amp;quot;, {tag, &amp;quot;0.4.0&amp;quot;}}}
  &amp;#93;}.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Running ``rebar3 compile`` again will pull down this library and all of its dependencies, making all of their modules and include files available for use in your LFE code. (Note that if you want to use the thrushing macros, you'll need to put ``(include-lib "clj/include/compose.lfe")`` after your ``defmodule``.)&lt;/p&gt;&lt;h2&gt;LFE Plugins&lt;/h2&gt;&lt;p&gt;The LFE compile plugin is written in Erlang. However, all the other LFE-rebar3 plugins currently under development are written in LFE itself. There are a few &lt;a href='https://github.com/lfe-rebar3'&gt;small utility plugins&lt;/a&gt; that we've been experimenting with, but perhaps the most useful plugin right now is the &lt;a href='https://github.com/lfe-rebar3/lodox'&gt;lodox&lt;/a&gt; documentation-generator (inspired by Clojure's &lt;a href='https://github.com/weavejester/codox'&gt;Codox&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;If you'd like to use this plugin, simply add it to your other ``rebar3`` plugins:&lt;/p&gt;&lt;pre&gt;&lt;code class="erlang"&gt;{plugins, &amp;#91;
   {'lfe-compile',
     {git, &amp;quot;https://github.com/lfe-rebar3/compile.git&amp;quot;, {tag, &amp;quot;0.3.0&amp;quot;}}},
   {lodox,
     {git, &amp;quot;https://github.com/lfe-rebar3/lodox.git&amp;quot;, {tag, &amp;quot;0.12.10&amp;quot;}}}
  &amp;#93;}.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then you are ready to use it to generate HTML docs for your LFE source code:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 lfe lodox
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;``rebar3`` Features&lt;/h2&gt;&lt;p&gt;``rebar3`` is a fantastic tool with a whole suite of incredibly useful features. If you run the following command:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 --help
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;part of the output will show the standard commands that come with the tool (many of which also take their own subcommands; try out ``rebar new &amp;ndash;help``):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;as                Higher order provider for running multiple tasks in ...
clean             Remove compiled beam files from apps.
compile           Compile apps .app.src and .erl files.
cover             Perform coverage analysis.
ct                Run Common Tests.
deps              List dependencies
dialyzer          Run the Dialyzer analyzer on the project.
do                Higher order provider for running multiple tasks in ...
edoc              Generate documentation using edoc.
escriptize        Generate escript archive.
eunit             Run EUnit Tests.
help              Display a list of tasks or help for a given task or subtask.
new               Create new project from templates.
path              Print paths to build dirs in current profile.
pkgs              List available packages.
release           Build release of project.
relup             Create relup of releases.
report            Provide a crash report to be sent to the rebar3 issues page.
shell             Run shell with project apps and deps in path.
tar               Tar archive of release built of project.
tree              Print dependency tree.
unlock            Unlock dependencies.
update            Update package index.
upgrade           Upgrade dependencies.
version           Print version for rebar and current Erlang.
xref              Run cross reference analysis.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that if you have a bunch of LFE plugins configured for use in your project, you'll also see those displayed as part of the output of ``rebar3 help``:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lfe &amp;lt;task&amp;gt;:
  clean          The LFE rebar3 clean plugin.
  compile        The LFE rebar3 compiler plugin
  lodox          Generate documentation from LFE source files.
  repl           The LFE rebar3 LFE REPL plugin.
  test           The LFE rebar3 test plugin.
  version        The LFE rebar3 version plugin.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I've found the ``tree`` command quite helpful to track down explicit dependencies and their versions when debugging issues between projects:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 tree
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;===&amp;gt; Verifying dependencies...
└─ lsci─0.0.2 &amp;#40;project app&amp;#41;
   ├─ encurses─0.4.1 &amp;#40;git repo&amp;#41;
   └─ py─0.0.5 &amp;#40;git repo&amp;#41;
      ├─ erlport─0.9.8 &amp;#40;git repo&amp;#41;
      ├─ logjam─0.4.0 &amp;#40;git repo&amp;#41;
      â  ├─ color─0.2.0 &amp;#40;git repo&amp;#41;
      â  ├─ lager─3.1.0 &amp;#40;git repo&amp;#41;
      â  â  └─ goldrush─0.1.8 &amp;#40;git repo&amp;#41;
      â  └─ lcfg─ &amp;#40;git repo&amp;#41;
      â     └─ ltest─0.8.0 &amp;#40;git repo&amp;#41;
      └─ lutil─0.8.0 &amp;#40;git repo&amp;#41;
         ├─ clj─0.4.0 &amp;#40;git repo&amp;#41;
         â  └─ kla─0.6.0 &amp;#40;git repo&amp;#41;
         └─ lfe─1.0 &amp;#40;git repo&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Profiles&lt;/h2&gt;&lt;p&gt;This ``rebar3`` feature is important enough for its own section :-) You can read about ``rebar3`` profiles &lt;a href='https://www.rebar3.org/docs/profiles'&gt;here&lt;/a&gt; but in short, they allow you to split up potentially very large ``rebar.config`` files into sections that will only get run if a particular profile is active.&lt;/p&gt;&lt;p&gt;Practically speaking, this means that you can do things like the following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;allow your users to only download the minimum dependencies when compiling  your library&lt;/li&gt;&lt;li&gt;for example, only downloading and compiling the testing framework when  running tests, or&lt;/li&gt;&lt;li&gt;only downloading doc tools when running the "docs" profile&lt;/li&gt;&lt;li&gt;providing developer tools only run running the "dev" profile&lt;/li&gt;&lt;li&gt;set explicit dependencies on a per-profile basis&lt;/li&gt;&lt;li&gt;avoid some cyclic dependency issues&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This drastically reduced download and compile times for several of our more dependency-heavy libraries. [Here's an example](https://github.com/lfex/exemplar/blob/master/rebar.config) of an LFE project's ``rebar.config`` file making good use of the profiles feature. In that example, you can run the following commands to perform the per-profile actions:&lt;/p&gt;&lt;p&gt;Run the unit tests:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 as test eunit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Get detailed version info:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 as dev lfe version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Build the API reference for the project:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ rebar3 as docs lfe lodox
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We've only just started using ``rebar3`` profiles in some of the LFE libraries, but we're already pretty big fans.&lt;/p&gt;&lt;h2&gt;Community Goals&lt;/h2&gt;&lt;p&gt;Our ultimate goal with rebar3 is to provide a suite of genuinely useful LFE plugins (written in LFE) that devs adore using. One of the things we've got slated for up-coming hack time is templates for LFE projects: not only providing LFE versions of the Erlang ones that ship with ``rebar3`` but also YAWS, elli, and LFE Dragon templates.&lt;/p&gt;</content></entry><entry><title>clojang v0.1.0 Released</title><updated>2016-02-15 02:04:57</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2016-02/15-020457/clojang-v0-1-0-released.html"/><id>urn:oubiwann-github-io/blog:feed:post:clojang v0.1.0 Released</id><content type="html">&lt;p&gt;After two months of intense development, the first (alpha) release of clojang is out!&lt;/p&gt;&lt;p&gt;Available &lt;a href='https://github.com/clojang/clojang/releases/tag/0.1.0'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Enjoy!&lt;/p&gt;</content></entry><entry><title>Zhang</title><updated>2016-02-13 12:15:26</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2016-02/13-121526/zhang.html"/><id>urn:oubiwann-github-io/blog:feed:post:Zhang</id><content type="html">&lt;p&gt;Today &lt;a href='http://github.com/clojang'&gt;yet another Clojang project&lt;/a&gt; was created:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/zhang'&gt;zhang&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;From the project's README, here is a (partial) list of desired features:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the ability to quickly create and destroy processes, nodes, and mboxes&lt;/li&gt;&lt;li&gt;ensure the safe "crashing" of a process&lt;/li&gt;&lt;li&gt;very fast message-passing between processes&lt;/li&gt;&lt;li&gt;the ability support very large numbers of processes&lt;/li&gt;&lt;li&gt;shared nothing&lt;/li&gt;&lt;li&gt;low-overhead function-level mailboxes&lt;/li&gt;&lt;li&gt;ordered message queues&lt;/li&gt;&lt;li&gt;timeouts&lt;/li&gt;&lt;li&gt;pattern matching (&lt;code&gt;core.match&lt;/code&gt;) and selective &lt;code&gt;receive&lt;/code&gt;&lt;/li&gt;&lt;li&gt;process registration hooks (in order to support arbitrary publishing mechanisms)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A great deal of work (and time in production deployments) has gone into Erlang's JInterface Java package. Using it in Clojure has been such a pain, however, that two projects were created to mitigate two major issues around that (Clojure idioms and sane OTP defaults). Even with these libraries under active development, their ultimate goals (and areas of focus) are beyond the scope of addressing the JInterface internals of threads, sockets, and queues. As such, zhang was created to find a good solution for replacing those bits with &lt;code&gt;core.async&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The project is experimental in nature and will likely be developed only very slowly, especially while &lt;a href='https://github.com/clojang/jiface'&gt;jiface&lt;/a&gt; and &lt;a href='https://github.com/clojang/clojang'&gt;clojang&lt;/a&gt; are in development. Once those projects hit a level of stability, though, I expect to be spending more time on the interesting problems to be solved in zhang.&lt;/p&gt;&lt;p&gt;Additionally, I expect that zhang, jiface, and clojang will end up sharing a certain amount of code. Only once jiface and clojang stabilize will it become clear what common bits for zhang can be split out into supporting library projects. I expect that one of these will be the type conversions developed in clojang (i.e., there will likely eventually be a clojang/types library and corresponding repo).&lt;/p&gt;&lt;p&gt;Since zhang aims to be messaging and deployment agnostic, there could also be a set of message implementation libraries created &amp;ndash; the first of which would be the default: OTP process messaging. However, there's no reason other message formats couldn't be implemented or integrated. This would allow zhang (and thus Clojang in general) to transcend the current domain of OTP messaging and take fault-tolerant, soft real-time programming into other areas of the Clojure ecosystem.&lt;/p&gt;&lt;p&gt;On a fun side note, the zhang project takes it's name from &lt;a href='https://en.wikipedia.org/wiki/Zhang_Heng'&gt;Zhang Heng&lt;/a&gt;, who approximated pi early in the first millennium (Han Dynasty). This is an obscure pun, since the Erlang process model could be, in some ways, interpreted as an approximation of the &lt;a href='https://en.wikipedia.org/wiki/%CE%A0-calculus'&gt;process calculus&lt;/a&gt;. In addition to being a mathematician, Zhang Heng was also a poet, astronomer, and engineer &amp;ndash; a wonderful patron for a software project :-)&lt;/p&gt;</content></entry><entry><title>Announcing jiface, clojang, &amp; a Clojure OTP agent</title><updated>2016-01-19 18:42:24</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2016-01/19-184224/announcing-jiface-clojang-a-clojure-otp-agent.html"/><id>urn:oubiwann-github-io/blog:feed:post:Announcing jiface, clojang, &amp; a Clojure OTP agent</id><content type="html">&lt;p&gt;After all the hacking on the Clojure/LFE/Erlang code &amp;ndash; a prototype version of Clojang &amp;ndash; it has become clear that Clojang really needs to be split into projects with separate concerns. Firstly, there needs to be a dedicated project for two very distinct aspects of this mini-ecosystem:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;There should be a low-level Clojure wrapper around JInterface (having to  write   OTP-interop code using Clojure's Java interop makes for unbelievably  ugly code ...). This library should have no opinions about anything, instead  simply providing a minimally Clojure-idiomatic wrapper around JInterface.&lt;/li&gt;&lt;li&gt;In addition, there needs to be a mid-level API that wrapps jiface and allows  one to use even more idiomatic Clojure (and perhaps some LFE-isms, too). This  library can have the luxury of being opinionated about how things should be  done, including default nodes, mboxes, etc., as well as automatic conversion  of Erlang/OTP types.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Finally, there is a bit of functionality that can be broken out into another project, usable by clojang and other higher-level libs that would benefit from some basic OTP conveniences: a &lt;a href='http://github.com/clojang/agent'&gt;Clojure/Java agent&lt;/a&gt; that helps set up a default OTP node in Clojure applications.&lt;/p&gt;&lt;p&gt;The home for these projects is here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://github.com/clojang'&gt;githb.com/clojang&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Or, individually:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/jiface'&gt;githb.com/clojang/jiface&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/clojang'&gt;githb.com/clojang/clojang&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://github.com/clojang/agent'&gt;githb.com/clojang/agent&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The work started last year on &lt;a href='https://github.com/awetzel/clojure-erlastic'&gt;a fork of Arnaud Wetzel'a code&lt;/a&gt;, while interesting at first, doesn't really provide a general and open-ended solution that's needed for larger-scale applications. As such, the new version of clojang &amp;ndash; as well as its other new sister projects &amp;ndash; represents a completely fresh start with no shared code history. This should leave things maximally flexible.&lt;/p&gt;</content></entry><entry><title>Update: Running an LFE YAWS app in Docker</title><updated>2015-11-28 21:10:08</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2015-11/28-211008/update-running-an-lfe-yaws-app-in-docker.html"/><id>urn:oubiwann-github-io/blog:feed:post:Update: Running an LFE YAWS app in Docker</id><content type="html">&lt;p&gt;&lt;a href="/assets/images/posts/DockerLogo.png"&gt;&lt;img class="left thumb" src="{{ site.base_url }}/assets/images/posts/DockerLogo.png" /&gt;&lt;/a&gt;Last December we posted a &lt;a href='/tutorials/2014/12/07/1837-running-lfe-in-docker/'&gt;blog entry&lt;/a&gt; about Docker &lt;a href='https://www.docker.com/'&gt;Docker&lt;/a&gt; and LFE. Since that time there have been several version changes in Erlang, LFE, and the LFE libraries used. In addition, the process to get the demo Dockerized YAWS web app running has been streamlined. This post covers those changes.&lt;/p&gt;&lt;h2&gt;Setup&lt;/h2&gt;&lt;p&gt;If you are running on Mac OS X, you'll need to install and start &lt;a href='http://boot2docker.io/'&gt;boot2docker&lt;/a&gt;. If you're running on Linux, you'll need to start the ``docker`` services (for instance, on Ubuntu, ``sudo /etc/init.d/docker start``)&lt;/p&gt;&lt;h3&gt;Port-Forwarding&lt;/h3&gt;&lt;p&gt;Docker on Linux handles port-redirects between the host and guest just fine; for Docker on Mac OS X, you'll need to setup port-forwarding via SSH:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ boot2docker ssh -L &amp;lt;HOSTMACHINE&amp;gt;:5099:127.0.0.1:5099
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then just leave that terminal window open and continue with the rest of this post in another terminal.&lt;/p&gt;&lt;h2&gt;LFE Exchange Docker Images&lt;/h2&gt;&lt;p&gt;There are several LFE Docker images to choose from, all available via the LFEX Docker Hub org:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;https://hub.docker.com/u/lfex/&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;They are of two different types:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;One image generated from the ``Dockerfile`` maintained in the   &lt;a href='https://github.com/rvirding/lfe/'&gt;official LFE repository&lt;/a&gt; using the ``develop``   branch&lt;ul&gt;&lt;li&gt;All the others which are maintained in the  &lt;a href='https://github.com/lfex/dockerfiles'&gt;lfex dockerfiles repository&lt;/a&gt; are kept in  sync with the official ``develop`` branch but also offer the added  feature of a &lt;a href='https://github.com/rvirding/lfe/pull/116'&gt;color logo banner&lt;/a&gt;  when you start up the LFE REPL.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;YAWS LFE Docker Image&lt;/h2&gt;&lt;p&gt;As part of the update of the old post, I've created a Docker with YAWS and the demo web app pre-installed and ready to go. It's available here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;https://hub.docker.com/r/oubiwann/lfe-yaws-sample-app/&lt;ul&gt;&lt;li&gt;https://github.com/oubiwann/docker-lfe-yaws-sample-app/&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For the last blog post we used the &lt;a href='https://hub.docker.com/r/lfex/opensuse/'&gt;OpenSUSE image&lt;/a&gt;, but for this one we've based off of the &lt;a href='https://hub.docker.com/r/lfex/debian/'&gt;Debian image&lt;/a&gt;, since it's the smallest one.&lt;/p&gt;&lt;p&gt;If you'd rather build the YAWS LFE sample app Docker image yourself than download it from Docker Hub, simply run ``make docker-build`` from the cloned source directory for the ``docker-lfe-yaws-sample-app`` project.&lt;/p&gt;&lt;h2&gt;Running the Container&lt;/h2&gt;&lt;p&gt;Whether you build the image yourself or chose to let ``docker`` download it for you from Docker Hub, either way the same command is used to run the container:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ docker run -p 5099:5099 -t oubiwann/lfe-yaws-sample-app:latest
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Almost immediately the YAWS app will be up and running. Visiting ``http://&lt;HOSTMACHINE&gt;:5099`` in a web browser will show the running YAWS LFE web app:&lt;/p&gt;&lt;p&gt;&lt;img src="{{ site.base_url }}/assets/images/posts/docker-lfe-sample-app-main-page.png" /&gt;&lt;/p&gt;&lt;h2&gt;The LFE REPL&lt;/h2&gt;&lt;p&gt;If, instead of running the app server, you'd like to use the LFE REPL on this image with all of the dependent libraries, you can run this command instead:&lt;/p&gt;&lt;pre&gt;&lt;code class="bash"&gt;$ docker run -i -t oubiwann/lfe-yaws-sample-app:latest lfe
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src="{{ site.base_url }}/assets/images/posts/lfe-color-banner.png" /&gt;&lt;/p&gt;&lt;h2&gt;Why the Update?&lt;/h2&gt;&lt;p&gt;Due to the question of a curious community member, I'm now preparing a blog post on using YAWS websockets support with an LFE app. I wanted to use the sample app featured in the original LFE Docker blog post (linked at the beginning of this post), but it needed some updates and further finessing ... upon the completion of which, it warranted a new post describing how to use it now.&lt;/p&gt;&lt;p&gt;Keep your eyes peeled for the websockets post ...&lt;/p&gt;&lt;h2&gt;An LFE Web App Aside&lt;/h2&gt;&lt;p&gt;If you'd like to look at the source code for this sample app, it has been made available here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/oubiwann/docker-lfe-yaws-sample-app'&gt;https://github.com/oubiwann/docker-lfe-yaws-sample-app&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It takes advantage of two interesting LFE libraries:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/lfex/lfest'&gt;lfest&lt;/a&gt; - a   Clojure/&lt;a href='https://github.com/weavejester/compojure'&gt;Compojure&lt;/a&gt;-like   macro for defining app routes&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/lfex/exemplar'&gt;exemplar&lt;/a&gt; - an LFE library for HTML as   LFE-native s-expressions&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>lfecljapp v0.3.0 Release</title><updated>2015-09-19 20:20:40</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2015-09/19-202040/lfecljapp-v0-3-0-release.html"/><id>urn:oubiwann-github-io/blog:feed:post:lfecljapp v0.3.0 Release</id><content type="html">&lt;p&gt;The project that kicked this whole thing off just got a series of updates. In fact, it got enough of them to warrant a new release. However, this will likely be the last significant update for a while, since I'm going to spend any time I have for this work on core libraries of jiface and clojang.&lt;/p&gt;&lt;p&gt;Hopefully, the next release of lfecljapp will be using released versions of jiface, clojang, and the agent.&lt;/p&gt;&lt;p&gt;Stay tuned ...&lt;/p&gt;</content></entry><entry><title>An Interview with Robert Virding on Lisp</title><updated>2015-09-18 22:30:08</updated><author><name>oubiwann</name></author><link href="http://oubiwann.github.io/blog//blog/archives2015-09/18-223008/an-interview-with-robert-virding-on-lisp.html"/><id>urn:oubiwann-github-io/blog:feed:post:An Interview with Robert Virding on Lisp</id><content type="html">&lt;p&gt;&lt;a href="{{ site.base&lt;i&gt;url }}/assets/images/posts/Robert-Train.png"&gt;&lt;img class="left medium" src="{{ site.base&lt;/i&gt;url }}/assets/images/posts/Robert-Train.png" /&gt;&lt;/a&gt;If you've been watching the &lt;a href='http://groups.google.com/group/lisp-flavoured-erlang'&gt;LFE mail list closely&lt;/a&gt;, then you will have noticed that we're working on LFE's first book. That's super-exciting, but for a future post or two all of their own. Several months ago I was getting chapter 1 ready for the reviewers, and I needed some clarification on a few points from Robert Virding regarding some of LFE's historical details.&lt;/p&gt;&lt;p&gt;So I did what was natural: asked a bunch of completely unrelated questions! Well, to be honest, they were related tangentially and they helped put together a more complete picture of LFE's early history. It ended up being a bit of a mini-interview, and I enjoyed Robert's responses so much, I asked him if it was okay to share with the wider LFE community &amp;ndash; he agreed and the plan was back-burnered for when I had a chance to create a post with the questions and answers.&lt;/p&gt;&lt;p&gt;Robert and I had a few more related conversations around the same time &amp;ndash; I've taken a bit of artistic liberty in weaving the additional email conversations into a single narrative.&lt;/p&gt;&lt;p&gt;I hope you enjoy this as much as I did :-)&lt;/p&gt;&lt;p&gt;&lt;hr /&gt;&lt;/p&gt;&lt;p&gt;Duncan: **When did you first encounter Lisp? Where were you working and/or going to school?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: I first encountered Lisp somewhere around 1980-81. I was in the Physics department at Stockholm University and had started taking my PhD in theoretical physics there.&lt;/p&gt;&lt;p&gt;Duncan: &lt;strong&gt;What was your initial reaction to Lisp?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: They were using it at the department for algebraic calculations in theoretical physics which is why I came into contact with it. I was (not yet) a part of that work so, while it was cool, I didn't really see the beauty of it right away.  At that time I was doing programming of more "normal" types of applications, tools for student labs and micro-processor programming in labs, using more traditional languages like Pascal and various assemblers.&lt;/p&gt;&lt;p&gt;Duncan: **What where the primary hurdles you had to overcome when initially learning Lisp?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: My major difficulty was in grasping that the parentheses defined a data structure and were not just for grouping as in other languages. Why wasn't ``(foo (1) (2) (3))`` the same as ``(foo 1 2 3)``. Once I got that, it was easy. The prefix notation was no problem as I had done some work with Forth (and had implemented one), so I was used to not having infix operators.&lt;/p&gt;&lt;p&gt;Duncan: **What projects did you work on where Lisp was a major aspect of the work?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: I didn't really use Lisp deeply at the Physics department. They had a VAX 780 running VMS and had &lt;a href='https://en.wikipedia.org/wiki/Eunice_%28software%29'&gt;Eunice&lt;/a&gt;, so I tested &lt;a href='https://en.wikipedia.org/wiki/Franz_Lisp'&gt;Franz Lisp&lt;/a&gt;.  When I left and joined Ericsson they were also using Vax/VMS so I borrowed Eunice to continue with Lisp. I thought it would be interesting to see if I could port Franz Lisp to straight-VMS. It was much more UNIX/BSD dependent than I originally thought, which resulted in me having to implement more of BSD on top of VMS than I had planned. Maybe I can share those details with you later, they are not really interesting here, for this Lisp discussion.  As far as I know no-one except me ever used it, but it did wonders for my C and understanding of how OSes work!&lt;/p&gt;&lt;p&gt;I did more work with Lisp when I was a member of the &lt;a href='http://web.archive.org/web/20000817053822/http://www.ericsson.se/cslab/admin/jubileumsskrift.html'&gt;Computer Science Lab&lt;/a&gt; in Ericsson where we were looking at various ways of implementing telecom applications. Lisp was one the languages we were investigating, and as part of that work I studied implementing Lisps. I also implemented the Lisp Machine Flavors system as a study of implementing a relatively complex system in and on Lisp ... and for the fun of it as well.&lt;/p&gt;&lt;p&gt;We later moved on to look at logic languages and these became the base on which Erlang was built, even though Erlang itself became functional.&lt;/p&gt;&lt;p&gt;Duncan: &lt;strong&gt;Can you tell me more about the Flavors project?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: Well, it's probably not well-known that the name LFE &amp;ndash; Lisp Flavoured Erlang &amp;ndash; was partly inspired by the work I did on porting Flavors to VMS, with the spelling changed to the English "Flavours" as a joke.&lt;/p&gt;&lt;p&gt;Duncan: **Were you using an LMI Lambda? If it wasn't a Symbolics machine, then it probably wasn't ZetaLisp ... so were you using the Maclisp-derived Lisp for the Lambda?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: No, it was other way around. I was using PSL (&lt;a href='https://en.wikipedia.org/wiki/Portable_Standard_Lisp'&gt;Portable Standard Lisp&lt;/a&gt;) from Utah which was quite a good Lisp implementation running on UNIX, amongst other systems. I had heard about Flavors and thought it would be interesting, and fun, to see if I could implement it on PSL. I managed to get hold of the Lisp Machine Flavors documentation and got going.&lt;/p&gt;&lt;p&gt;Flavors was an extremely feature-filled system; someone had really gone to town with it. It had multiple inheritance, mix-in flavors, before and after handlers, and wrapper macros. It also had a set of rules describing which were to be called and when. It was wonderful. Fortunately, Flavors had a few features which made it easier. For example, there was an explicit ``send`` function so I didn't need to hack PSL itself.&lt;/p&gt;&lt;p&gt;All in all, it worked. But I never really had a proper use-case. Unfortunately, I think the code has disappeared &amp;ndash; at least, I haven't been able to find it. It would almost be doable on LFE except for updating object state; you would have to modify it to return the new object instead. Or use processes, but then they may be a little heavy.&lt;/p&gt;&lt;p&gt;Duncan: **After gaining experience in school and work with Lisp, what features did you feel made Lisp an excellent tool or even just fun to work with?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: I liked working with functional languages and I found Lisp to be very versatile when building systems. The combination of functions and macros &amp;ndash; and the homoiconicity which makes working with macros easy &amp;ndash; makes Lisp a very powerful tool. This makes Lisp and the concurrency from Erlang a very good combination.  One wonders how it would have gone if we had used Lisp as a base for Erlang.&lt;/p&gt;&lt;p&gt;Duncan: **In 2007, when you started working on what would become LFE, when was the last time you had implemented a language? Was it in 1986 when you had implemented the variants of the parallel logic programming languages?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: In addition to the work on the parallel programming languages, I did a number of implementations of Erlang to study different techniques as well as to study the possibilities of using different memory management and garbage collection mechanisms like reference-counting and a real-time copying collector. These presented no significant benefit over the separate-process-heap model used in the "standard" Erlang implementations, so the work was discontinued.&lt;/p&gt;&lt;p&gt;I did some work with the BEAM implementation, amongst other things, the compiler, and also parts of the basic system.&lt;/p&gt;&lt;p&gt;Duncan: **Coming back to the parallel programming, I saw a reference to the 1986 paper you co-authored, entitled &lt;em&gt;The Phoning Philosopher's Problem or Logic Programming for Telecommunications Applications&lt;/em&gt;, where &lt;a href='https://en.wikipedia.org/wiki/Parlog'&gt;Parlog&lt;/a&gt; was used to create what looked like an Erlang prototype. Was this the first version of Erlang?**&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Robert&lt;/strong&gt;: No, the Erlang language did not exist in 1986; using the name "Erlang" pre-dates the current Erlang language. The 1986 paper was describing a language/system based on concurrent logic which we called "Erlang". It was mainly done by a guy called Nabiel Elshiewy and myself. Actually this path was abandoned and has nothing to do modern Erlang. Which I think is a great shame, as I liked the concurrent logic languages. I still do.&lt;/p&gt;&lt;p&gt;Work on what became Erlang didn't really start until '87/'88. Before that almost all the members of the lab had written telecom applications in a variety of languages and systems &amp;ndash; basically everything that ran on BSD or UNIX &amp;ndash; to experiment with ways of solving the problem.&lt;/p&gt;</content></entry></feed>